Uniform Resource Identifiers
  - A sequence of characters that identifies resources.
  - No limit on the nature of the resource or reason for ID'ing resource.
  - Is essentially the idea of having an address (or ID) for shit on a network
    so that things in that network can see the resource.
  - Interpretation of a URI is consistent regardless of context. That interpretation
    is up to the implementation of the end user though.

  Generic syntax of a URI are as follows (RFC3986)
    URI         = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
      hier-part   = "//" authority path-abempty
                / path-absolute
                / path-rootless
                / path-empty
          authority   = [ userinfo "@" ] host [ ":" port ]
          userinfo    = *( unreserved / pct-encoded / sub-delims / ":" )
            host        = IP-literal / IPv4address / reg-name
  *look at RFC3989-3.2.2.Host for more host info*
  port        = *DIGIT


  - Example URI
    foo://example.com:8042/over/there?name=ferret#nose

HTTP/1.1 Message format
  - Servers and clients communicate via HTTP messages (request OR a response).
  - Practically speaking, servers only expect a request and clients only expect a response.

  - Recipient of a message MUST parse a message as a sequence of octets in a superset of ASCII (0-255, 00-FF). DO NOT parse message as a stream of unicode characters.
  - Server and client have special behavior that is really specific (for carriage return and line feed character edge cases for security).

  - HTTP messages starts with the version. HTTP 1.0 requests should work with 1.1 servers.

  - The next line is the "request-line" that has a method token, a single space, the request-target, and another single space (ending with the HTTP-version).
  - Be wary of how the server treats white space because of possible request smuggling security vulnerabilities.

  - The next request-target is the resource that the server is being asked to apply the request to. No whitespace is allowed. No autocorrection of the request-target should be done.
  - Server and client have specific behavior for handling some edge cases.
  - There are four different ways that a request-target is formatted
    1. origin-form (absolute-path with a query, HOST afterwards)
    2. absolute-form (absolute-URI)
    3. authority-form (uri-host : port, HOST afterwards)
    4. asterisk-form (used for server-wide OPTIONS request)

  - The server receives a message with these parts and reconstructs the target-uri.
    GET /pub/WWW/TheProject.html HTTP/1.1
    Host: www.example.org

    reconstructs into

    https://www.example.org/pub/WWW/TheProject.html

  - The other way messages are used are as responses, or status-line(s).
  - These are formatted with the HTTP version, a single space, the status code, another single space, and then an OPTIONAL "reason-phrase." White-space delimited word boundaries is allowed with a lot of specifics though.
  - Status codes are three digit numbers, reason-phrase is completely optional textual description that a sever sends to a client.


HTTP Methods
	- HTTP/1.0 has GET, HEAD, POST, along with PUT, DELETE, LINK, and UNLINK.
	- HTTP/1.1 added PUT, DELETE, CONNECT, OPTIONS, and TRACE.

	- GET is a request for a represenation of a resource.
	- HEAD is a GET without representation of a resource.
	- POST is a request to process a resource.
	- PUT is a POST but the client specifies the target location.
	- DELETE is a delete request.
	- CONNECT establishes a TCP/IP tunnel to a specified server. Used for proxies with TLS
	- OPTIONS is basically a debug request.
	- TRACE ""
	- PATCH ...

HTTP status codes
	...


HTTP headers
	- HOLY FUCK THERE ARE SO MANY

HTTP Content Negotiation
	- Given headers in a request a client can give a preference for a version of a resource. Example, languages or file types.
	- 

Same Origin Policy and Cross-origin resource sharing
	- SOP is a security measure that is taken to protect pages within the HTML DOM. If a user agent tries to access a page it is allowed only if both pages have the same origin (found in the headers).
	- Sometimes we want to bypass this ("cross-domain" requests) so we can use CORS to safely do this.
	- WebSockets is the most modern version of bypassing this policy.
